---
tag: [Compiling principle]
catalog: true
header-img: img\blog5.jpg 
---  
> <font color = "blue" face = "楷体">只是单纯地想念一个人也是如此的美好   
> ——liuhaihua<早校车></font> 


## 实验目的   
1、	学会针对DFA转换图实现相应的高级语言源程序。  
2、	深刻领会状态转换图的含义，逐步理解有限自动机。  
3、	掌握手工生成词法分析器的方法，了解词法分析器的内部工作原理。  
##	实验内容  
(自己设计的某种计算机语言)的编译程序的词法分析部分实现。  
从左到右扫描每行该语言源程序的符号，拼成单词，换成统一的内部表示（token）送给语法分析程序。
为了简化程序的编写，有具体的要求如下：   
（1）	数包含整型和浮点型。  
（2）	空白符仅仅是空格、回车符、制表符。  
（3）	代码是自由格式。  
（4）	注释应放在花括号之内，并且不允许嵌套  
给出自己的记号定义。举例如下：  
![1](/picture\TINY语言的记号.png)    
## 实验要求          
要求实现编译器的以下功能：         
（1）	按规则拼单词,并转换成二元式形式  
（2）	删除注释行  
（3）	删除空白符 (空格、回车符、制表符)   
（4）	列表打印源程序，按照源程序的行打印，在每行的前面加上行号，并且打印出每行包含的记号的二元形式  
（5）	发现并定位错误  
自己设计的词法分析进行具体的要求：  
（0）	给出词法分析程序使用的状态图(DFA)  
（1）	记号的二元式形式中种类采用枚举方法定义；其中保留字和特殊字符是每个都一个种类，标示符自己是一类，数字是一类；单词的属性就是表示的字符串值。   
（2）	词法分析的具体功能实现是一个函数GetToken()，每次调用都对剩余的字符串分析得到一个单词或记号识别其种类，收集该记号的符号串属性，当识别一个单词完毕，采用返回值的形式返回符号的种类，同时采用程序变量的形式提供当前识别出记号的属性值。   
（3）	标示符和保留字的词法构成相同，为了更好的实现，把语言的保留字建立一个表格存储，这样可以把保留字的识别放在标示符之后，用识别出的标示符对比该表格，如果存在该表格中则是保留字，否则是一般标示符。  
## 实验结果（给出自己的样例及输出结果）  
测试用例：
~~~ 
{Test Token}
if id = 0 then
	read(id);
else
	write(id);
endif;

{Test Error}
错误^_^

{Test Repeat}
num := 20;
repeat
~~~  
![1](/picture\输出结果示例.png)    

------   
 
 - **Problem**
   - enum的使用
   - vector无length
   - 文件的相关操作
   - 读取整行 getline()
   - 比较简单的实现行号,<font color = "blue">特别的，大括号不在同一行</font>，预处理会删除块注释导致预处理前后行号不对应
   - unorder_map中`enum类型`作键或键值
   - enum 类型的使用
   - 第一次使用switch-case,哈哈

- **Soloution**    
	1. 剔除空白和注释（也可以修改文法使得语法中包含空白，但远非易事）
	2. 预读  
	3. 常量：当在输入流中出现一个数位序列时，词法分析器将向语法分析器传送一个词法单元。该词法单元包含终结符号 **num**及根据这些数位计算得到的整型属性值，终结符号`+`没有属性（将词法单元写做元组形式）
	4. 识别关键字和标识符
		1. 语言的文法通常都把标识符当作终结符号进行处理。  
		2. 将保留字作为关键字，使用一个表来保存字符串。使用一个散列表来实现从词素到词法单元的映射。
    5. 用枚举感觉增加工作量啊，搞不懂为什么用枚举。   

``` c++
 1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
/**══════════════════════════════════╗
*Author：    刘海华                                                   ║
*Job     ：我以我血荐轩辕                                              ║
*═══════════════════════════════════╣
*Start date    ：2020-04-28
*Descripption：
*
*
*═══════════════════════════════════╣
*End Date:       2020 -05-10
*═══════════════════════════════════╝

*/

// 由于考虑的不周到，我采取了把每行代码单独作为一个string
// 并作为一个vector的元素的方法，并且很不方便改动，所以很多涉及到跨行的功能没有完全正确实现，具体为以下
// 1. 某些情况下行号的正确性 2.括号的匹配问题 3. 块注释 4. 其它

#include <cctype>  // 分类和转换单个字符函数
#include <fstream>
#include <iostream>
#include <stack>
#include <string>
#include <unordered_map>  // 实现两种映射 映射1：字符到种类码的映射  映射2：种类码到词法单元的映射 映射3
#include <vector>
using namespace std;
void getToken(const string);  // 识别各类字符并获取种类码
void preTreatment(vector<string>&);
// 预处理删除注释行
// 删除换行和制表符(注：该程序无法识别块注释，只能识别行注释)
// 保留字，一符一码，对应枚举量A-U
// 运算符等特殊符号，一符一码 V-AM
// 标识符  ID
// 数字一类  Num
// 采用枚举方式定义

// 全局变量
enum type {
    A = 0,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    AA,
    AB,
    AC,
    AD,
    AE,
    AF,
    AG,
    AH,
    AI,
    AJ,
    AK,
    AL,
    AM,
    AN,
    ID,   // 标识符、关键字
    Num,  // 数字
    SS,   // 字符串常量
    CC,   // 字符常量
    ZZ = 44
};
// 映射1 只含一符一种
unordered_map<string, enum type> typeCode = {
    {"if", A},     {"else", B}, {"while", C},    {"do", D},     {"break", E},
    {"main", F},   {"int", G},  {"float", H},    {"double", I}, {"return", J},
    {"const", K},  {"void", L}, {"continue", M}, {"char", N},   {"unsigned", O},
    {"enum", P},   {"long", Q}, {"switch", R},   {"case", S},   {"auto", T},
    {"static", U}, {"+", V},    {"-", W},        {",", X},      {"/", Y},
    {"=", Z},      {"<", AA},   {">", AB},       {"{", AC},     {"}", AD},
    {";", AE},     {"(", AF},   {")", AG},       {"&", AH},     {"!=", AI},
    {"#", AJ},     {"[", AK},   {"]", AL},       {"|", AM},     {"<<", AN}};

// 映射2 只含一符一种
unordered_map<enum type, string> lexicalUnit = {{A, "<A,if>"},
                                                {B, "<B,else>"},
                                                {C, "<C,while>"},
                                                {D, "<D,do>"},
                                                {E, "<E,break>"},
                                                {F, "<F,main>"},
                                                {G, "<G,int>"},
                                                {
                                                    H,
                                                    "<H,float>",
                                                },
                                                {I, "<I,double>"},
                                                {J, "<J,return>"},
                                                {K, "<K,const>"},
                                                {L, "<L,void>"},
                                                {M, "<M,continue>"},
                                                {N, "<N,char>"},
                                                {O, "<O,unsigned>"},
                                                {P, "<P,enum>"},
                                                {Q, "<Q,long>"},
                                                {R, "<R,switch>"},
                                                {S, "<S,case>"},
                                                {T, "<T,auto>"},
                                                {U, "<U,static>"},
                                                {V, "<V,+>"},
                                                {W, "<W,->"},
                                                {X, "<X,','>"},
                                                {Y, "<Y, />"},
                                                {Z, "<Z,'='>"},
                                                {AA, "<AA,'<'>"},
                                                {AB, "<AB,'>'>"},
                                                {AC, "<AC,{>"},
                                                {AD, "<AD,}>"},
                                                {AE, "<AE,;>"},
                                                {AF, "<AF,(>"},
                                                {AG, "<AG,)>"},
                                                {AH, "<AI,&>"},
                                                {AI, "<AJ,!>"},
                                                {AJ, "<AK,#>"},
                                                {AK, "<AL,[>"},
                                                {AL, "<AL,]>"},
                                                {AM, "<AM,|>"},
                                                {AN, "<AN,<< >"}};
// 映射3 由于enum 类型的输出显示为数字，所以给出一个enum到string的映射
unordered_map<enum type, string> four{{ID, "ID"},
                                      {Num, "Num"},
                                      {SS, "SS"},
                                      {CC, "CC"}};
string token = "";  // 获取单个最长字符串
string source;      // 存储一行的字符串
char ch;            // 当前字符
vector<string> sourceCode;  // 获取源代码中的所有字符,每个元素是一行代码
int line = 1;               // 记录行号
int m = 0;                  // 获得种类符时的行号
int n = 0;                  // 每一行中下标的字符
enum type alp;              // 种类码值
string word;                // 获取单个有效最大字符串
stack<char> brackets[3];  // 括号的匹配

int main() {
    string fileName;
    cout << "输入需要打开的文件： ";
    cin >> fileName;

    ifstream fin;
    fin.open(fileName);
    if (!fin.is_open()) {
        cerr << "文件打开失败！" << endl;
        exit(1);
    }
    // 逐行读取代码,并将每行压进容器
    while (getline(fin, source)) {
        sourceCode.push_back(source);
    }
    fin.close();  // 关闭文件
    cout << "--------------------------------------------------------------"
         << endl;
    cout << "源代码为：" << endl;
    for (auto i : sourceCode) {
        cout << line++ << " : " << i << endl;
    }
    line = 1;
    preTreatment(sourceCode);
    for (auto i : sourceCode) {
        cout << "预处理后的程序：" << line++ << " : " << i << endl;
    }
    line = 1;
    // 逐行操作
    while (m < sourceCode.size()) {
        while (n < sourceCode[m].size()) {
            cout << line << " : ";
            getToken(sourceCode[m]);
            if (alp == ZZ) {
                cout << "词法分析错误!" << endl;
            } else if (alp >= A && alp <= AN) {
                cout << " : " << lexicalUnit[alp] << endl;
            } else {
                cout << " : <" << four[alp] << "," << word << '>' << endl;
            }
        }
        line++;
        n = 0;
        m++;
    }
    return 0;
}

void getToken(string s) {
    word = "";
    alp = ZZ;
    // 识别标识符
    if (s[n] == '_') {
        alp = ID;
        word += s[n];
        n++;
        while (n < s.size() &&
               (s[n] == '_' || isalpha(s[n]) || isdigit(s[n]))) {
            word += s[n];
            n++;
        }
    }
    // 识别标识符或关键字
    else if (isalpha(s[n])) {
        alp = ID;
        word += s[n];
        n++;
        while (n < s.size() && isalpha(s[n])) {
            word += s[n];
            n++;
            if (typeCode.count(word) == 1) {
                break;
            }
        }
        // 字符串是否在映射表1里
        if (typeCode.count(word) == 1) {
            alp = typeCode[word];
        }
    }
    // 识别数字
    else if (isdigit(s[n])) {
        alp = Num;
        word += s[n];
        n++;
        while (n < s.size() && s[n] == '.' || s[n] == 'E' || s[n] == 'e' ||
               isdigit(s[n])) {
            word += s[n];
            n++;
        }
    }
    // 识别字符串常量
    else if (s[n] == '"') {
        alp = SS;
        n++;
        while (n < s.size() && s[n] != '"') {
            word += s[n];
            n++;
        }
        n++;  // 过滤 后“
    }
    // 识别字符常量
    else if (s[n] == '\'') {
        alp = CC;
        n++;
        while (n < s.size() && s[n] != '\'') {
            word += s[n];
            n++;
        }
        n++;  // 过滤 后‘
    }
    // 识别特殊符号
    else
        switch (s[n]) {
            case '+':
                alp = V;
                n++;
                break;
            case '-':
                alp = W;
                n++;
                break;
            case ',':
                alp = X;
                n++;
                break;
            case '/':
                alp = Y;
                n++;
                break;
            case '=':
                alp = Z;
                n++;
                break;
            case '<':
                alp = AA;
                n++;
                if (s[n] == '<') {
                    alp = AN;
                    n++;
                }
                break;
            case '>':
                alp = AB;
                n++;
                break;
            case '{':
                alp = AC;
                n++;
                break;
            case '}':
                alp = AD;
                n++;
                break;
            case ';':
                alp = AE;
                n++;
                break;
            case '(':
                alp = AF;
                n++;
                break;
            case ')':
                alp = AG;
                n++;
                break;
            case '&':
                alp = AH;
                n++;
                break;
            case '!':
                n++;
                if (s[n] == '=') {
                    alp = AI;
                }
                break;
            case '#':
                alp = AJ;
                n++;
                break;
            case '[':
                alp = AK;
                n++;
                break;
            case ']':
                alp = AL;
                n++;
                break;
            case '|':
                alp = AM;
                n++;
                break;
        }
}

void preTreatment(vector<string>& v) {
    vector<string> temp;
    for (int i = 0; i < v.size(); i++) {
        string str = "";
        for (int j = 0; j < v[i].size(); j++) {
            // 行注释,识别到 ”//“直接跳过本行剩余部分字符
            if (v[i][j] == '/' && v[i][j + 1] == '/') {
                break;
            }
            // 块注释  没处理好 有点难
            /*           if (v[i][j] == '/' && v[i][j + 1] == '*') {
                                           j += 2;
                                           while (v[i][j] != '*' && v[i][j +
               1]
               != '/') { j++;
                                                   // 到达本行末尾
                                                   if (j == v[j].size() - 1)
               { if (i == v.size() - 1) cout << "注释出错，没有找到
               "",程序结束！" << endl; break;
                                                           }
                                                           i++;
                                                           // 最后一行
                                                   }
                                           }
           */
            // 删除换行、制表符、空格
            if (v[i][j] != '\n' && v[i][j] != '\t' && v[i][j] != ' ') {
                str = str + v[i][j];  // 添加其它字符
            }
        }
        temp.push_back(str);
    }
    v = temp;  // 预处理后的源代码
}  
```

<style type="text/css">
body {background-color: #F8F8FF}