---
tag: [Compiling principle]
catalog: true
header-img: img/blog4.jpg
---   
> <font color = "blue" face = "楷体">为天地立心，为生名立命，为往圣继绝学，为万世开太平。
> ——《横渠四句》</font>

# 形式化语言回顾
# 4.1 语法分析器的能
## 4.1.1 语法分析器的功能
## 4.1.2 语法分析器实现方法  
1. 自顶向下分析
2. 自顶向上分析   


------  


## 4.1.3自顶向下分析技术及识别算法   
- 在一个自顶向下语法分析的每一步中，关键问题是确定对一个非终结符号（比如A）应用哪个产生式。一旦选择了某个A产生式，语法分析过程的其余部分将相应产生式体中的终结符号和输入相匹配 . 
- 向前看符号：输入中当前被扫描的终结符号  
- 一般来说，为一个非终结符号选择产生式是一个“尝试并犯错”的过程。在产生式不合适时进行回溯，但是在预测语法分析的特殊情形下不需要进行回溯。
- 识别算法，识别程序
- 语法分析的基础是上下文无关文法  


-------  

## 4.1.4 要解决的问题  
# 4.2 自顶向下分析面临的问题  
## 4.2.1 引例
## 4.2.2 语法分析树的建立
## 4.2.3 问题及解决  
带回溯的自顶向下分析技术是面向目标的、试探的，因而带回溯的。所以存在问题：  
  1. 效率问题：效率低，因为回溯、查规则效率。
  2. 左递归问题：左递归的存在使自顶向下分析过程陷入无穷   




------
 

# 4.3 LL(1)分析技术  
## 4.3.1 先决条件   
1. 无左递归性
2. 避免回溯性
3. 改写成等价的右递归
4.   ![1](/picture\直接消除左递归.PNG) ![2](/picture/间接消除左递归.PNG)   



-----  

## 4.3.2 提取左因子
1. 公共左因子  
2.   ![1](/picture\提取左因子.PNG)    



------    

## 4.3.3 化简文法  
1. 文法中不含有有害规则和多余规则
2. 文法中不含有不可到达和不可终止的非终结符。 


-----   

## 4.3.4 回溯问题  
1. FIRST($$\alpha$$)  
2. FOLLOW(A)  
![1](/picture/计算FIRST集.PNG)
![2](/picture/计算FOLLOW集.PNG)  
3. 判断LL（1）文法
    1. 
First(
$$\alpha$$
)
$$\cap$$
FIRST(
$$\beta$$
)=
$$\emptyset$$
,也就是
$$\alpha$$
和
$$\beta$$
推导不出以同一个终结符为a为首的符号串；他们不应该都能推出空字
$$\epsilon$$  
    2. 若
$$\beta\stackrel{*}{\Rightarrow}\epsilon$$
,则有FIRST（
$$\alpha$$
）
$$\cap $$
FOLLOW(A)=
$$\emptyset$$
.即，若
$$\beta\stackrel{*}{\Rightarrow}\epsilon$$
.则
$$\alpha$$
所能推出的串的首符号不应在FOLLOW(A)中。   
4. 根据一个一个文法的FIRST和FOLLOW集合，我们将构造出“预测分析表”


-------   

# 4.4 递归预测分析器的构造  
## 4.4.1 递归预测分析器的构造  
$$\forall$$
A
$$\in$$
$$V_N$$
,构造一个递归过程，不妨命名为A。过程A根据当前向前看符号a处于A的哪个候选式的FIRST集合中，就选择那个候选式进行分析。根据选择的候选式，从左至右，若是终结符号，则和向前看符号匹配；若是非终结符号，则调用相应过程；若a
$$\in$$
FOLLOW(A),
则选择A
$$\rightarrow \epsilon$$  
.  

--------  

# 预测分析程序   
## 4.5.1 表驱动预测分析程序模型   
- 一个预测分析器程序由各个非终结符对应的过程组成。
- 也可以扩展一个预测分析器来获得一个语法制导的翻译器，预测分析器不能处理左递归的文法  
- 如果一个过程体中执行的最后一条语句是对该过程的递归调用，那么该调用就称为是`尾递归`的。  
- 使用尾递归消除和`过程体代替`的方法来优化一个非终结符号的相应过程。
- 之所以能够为LL(1)文法构造一个预测分析器，原因是只需要检查当前输入符号就可以为一个非终结符号选择正确的产生式。  
- 构造一个预测分析表  
  - 两条规则  

- <font color = blue>格局</font>  
  - 格局描述了栈中的内容和余下的输入。  
- 识别程序的数学模型——下推自动机
  - 下推自动机比有线状态自动机复杂：除了有线状态组成部分外，还包括一个长度不受限制的栈；下推自动机的状态迁移不但要参考有线状态部分，也要参照栈当前的状态；状态迁移不但包括有线状态的变迁，还包括一个栈的出栈或入栈过程。下推自动机可以理解为，借由加上读取一个容量无限栈的能力，扩充一个能做
$$\epsilon$$
-转移的非确定有限状态自动机     
  - 每一个下推自动机都接受一个形式语言。被“非确定下推自动机”接受的语言是上下文无关语言。



<style type="text/css">
body {background-color: #F5F5DC}